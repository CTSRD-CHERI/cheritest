# Matt N, 5 May 2015
#
# Generate random capability-instruction sequences and check for
# equivalance between model (L3) and implementation (BSV).  This script
# must be run in the 'ctsrd/cheritest/trunk/' directory.  The other
# main assumptions are:
#
#  * a BSV-compiled CHERI is present at '../../cheri/trunk/sim'
#  * an L3-compiled CHERI is available at the following location:

L3CHERI = "../../../l3mips/l3mips-cheri256"

# =======
# Imports
# =======

import subprocess
import os
import sys
import random

# ==============
# Compile a test
# ==============

def compile():
  AS      = "mips64-as"
  LD      = "mips-linux-gnu-ld"
  OBJCOPY = "mips64-objcopy"
  OBJDUMP = "mips64-objdump"
  LDFLAGS = ["-EB", "-G0", "-T", "test.ld", "-m", "elf64btsmip"]
  CFLAGS  = ["-EB", "-march=mips64", "-mabi=64", "-G0",
             "-ggdb", "-defsym", "TEST_CP2=1" ]
  MEMCONV = "../../cherilibs/trunk/tools/memConv.py"
  subprocess.call([AS] + CFLAGS  + ["-o", "obj/lib.o", "lib.s"])
  subprocess.call([AS] + CFLAGS  + ["-o", "obj/init.o", "init.s"])
  subprocess.call([AS] + CFLAGS  + ["-o", "obj/captest.o", "captest.s"])
  subprocess.call([LD] + LDFLAGS + ["-o", "obj/captest.elf", "obj/init.o",
                                    "obj/captest.o", "obj/lib.o"])
  subprocess.call([OBJCOPY] + ["-S", "-O", "binary",
                               "obj/captest.elf", "obj/captest.bin"])
  subprocess.call(["python", MEMCONV, "-b", "obj/captest.bin"])
  subprocess.call(["cp", "mem64.hex", "../../cheri/trunk/"])

# ==========
# Run a test
# ==========

def run():
  # Obtain output from L3
  outputL3 = subprocess.check_output(
               [L3CHERI] + ["--uart-in", "/dev/null",
                           "--ignore", "HI", "--ignore", "LO",
                           "--format", "raw", "obj/captest.bin"])
  regFileL3 = {}
  for line in outputL3.split("\n"):
    fields = line.split()
    if fields != []:
      if fields[0] == "PC":
        regFileL3["PC"] = "0x" + fields[1].lower()
      if fields[0] == "Reg":
        regFileL3[fields[1]] = "0x" + fields[2].lower()

  # Obtain output from BSV
  os.chdir('../../cheri/trunk')
  outputBSV = subprocess.check_output(["./sim", "+regDump"],
                                      stderr=subprocess.STDOUT)
  os.chdir('../../cheritest/trunk')
  regFileBSV = {}
  for line in outputBSV.split("\n"):
    fields = line.split()
    if len(fields) >= 3:
      if fields[0] == "DEBUG" and fields[1] == "MIPS":
        if fields[2] == "PC":
          regFileBSV["PC"] = fields[3].lower()
        if fields[2] == "REG":
          regFileBSV[fields[3]] = fields[4].lower()

  for k in regFileL3.keys():
    if regFileL3[k] != regFileBSV[k]:
      print ""
      print ("Register " + k + " differs:")
      print ("  model says: " + regFileL3[k])
      print ("  implementation says: " + regFileBSV[k])

# =======================================
# Generate random capability instructions
# =======================================

def genDWord():
  x = random.choice(
    [ random.randrange(0, 65536)
    , random.randrange(0xffffffffffff0000, 0xffffffffffffffff)
    , random.randrange(0, 0xffffffffffffffff)
    ])
  return ("0x%x" % x)

def genCIncBase(c):
  return [ "  dli $t0, " + genDWord()
         , "  cincbase " + c + ", " + c + ", $t0"
         ]

def genCIncOffset(c):
  return [ "  dli $t0, " + genDWord()
         , "  cincoffset " + c + ", " + c + ", $t0"
         ]

def genCSetBounds(c):
  return [ "  dli $t0, " + genDWord()
         , "  csetbounds " + c + ", " + c + ", $t0"
         ]

def genCSetLen(c):
  return [ "  dli $t0, " + genDWord()
         , "  csetlen " + c + ", " + c + ", $t0"
         ]

def genCSetOffset(c):
  return [ "  dli $t0, " + genDWord()
         , "  csetoffset " + c + ", " + c + ", $t0"
         ]

def genCAndPerm(c):
  return [ "  dli $t0, " + genDWord()
         , "  candperm " + c + ", " + c + ", $t0"
         ]

def genCFromPtr(c):
  return [ "  dli $t0, " + random.choice(["0", genDWord()])
         , "  cfromptr " + c + ", " + c + ", $t0"
         ]

def genCCheckPerm(c):
  return [ "  dli $t0, " + genDWord()
         , "  ccheckperm " + c + ", $t0"
         ]

def genCClearTag(c):
  return [ "  ccleartag " + c + ", " + c ]

def genCSet(c):
  return random.choice(
      5 * [genCIncBase(c)]
    + 5 * [genCIncOffset(c)]
    + 3 * [genCAndPerm(c)]
    + 3 * [genCSetLen(c)]
    + 3 * [genCSetOffset(c)]
    + 2 * [genCFromPtr(c)]
    + 1 * [genCClearTag(c)]
    + 1 * [genCCheckPerm(c)]
    )

# ===============
# Generate a test
# ===============

# Pre test-sequence code
prelude = [
    "# Auto-generated by fuzz_cap.py"
  , ""
  , ".set mips64"
  , ".set noreorder"
  , ".set nobopt"
  , ".set noat"
  , ""
  , ".global test"
  , "test: .ent test"
  , "  daddu   $sp, $sp, -32"
  , "  sd      $ra, 24($sp)"
  , "  sd      $fp, 16($sp)"
  , "  daddu   $fp, $sp, 32"
  , ""
  , "  jal     bev_clear"
  , "  nop"
  , "  dli     $a0, 0xffffffff80000180"
  , "  dla     $a1, bev0_common_handler_stub"
  , "  dli     $a2, 12 # instruction count"
  , "  dsll    $a2, 2  # convert to byte count"
  , "  jal memcpy"
  , "  nop"
  , "  dli     $a0, 0 # set to 1 on exception"
  , ""
  , "# Auto-genetated test case:"
  ]

# Post test-sequence code
postlude = [
    "# End of autogenerated test case"
  , ""
  , "  mtc0      $zero, $26  # Dump registers"
  , "  mtc0      $zero, $23  # Terminate simulator"
  , "  nop"
  , "  .end test"
  , ""
  , ".ent bev0_handler"
  , "bev0_handler:"
  , "  li        $a0, 1"
  , "  cgetcause $a1"
  , "  dmfc0     $a2, $14    # EPC"
  , "  mtc0      $zero, $26  # Dump registers"
  , "  mtc0      $zero, $23  # Terminate simulator"
  , "  nop"
  , "  .end bev0_handler"
  , ""
  , ".ent bev0_common_handler_stub"
  , "bev0_common_handler_stub:"
  , "  dla $k0, bev0_handler"
  , "  jr  $k0"
  , "  nop"
  , "  .end bev0_common_handler_stub"
  ]

# Returns True with probability 'p', and False otherwise
def chance(p):
  return random.random() < p

# Generate a random capability (through a random sequence of
# capability-modification instructions), then read the fields of the
# resulting capability into general-purpose registers.

def testSetGet():
  testseq = []
  for i in range(0,random.randrange(3,8)):
    testseq.extend(genCSet("$c0"))

  # Print test sequence
  for line in testseq:
    print line
  print

  # Query resulting capability
  testseq.extend(
    [ "  cgetperm   $s0, $c0"
    , "  cgetbase   $s1, $c0"
    , "  cgetlen    $s2, $c0"
    , "  cgetoffset $s3, $c0"
    , "  cgettag    $s4, $c0"
    , "  cgetsealed $s5, $c0"
    , "  cgettype   $s6, $c0"
    ])

  branch = random.choice(["cbts", "cbtu"])
  testseq.extend(
    [ "  " + branch + " $c0, skip"
    , "  nop"
    , "  li $s7, 0xffff"
    , "skip:"
    ])

  return testseq

# Generate two random capabilities, then compare the capabilities
# using CPtrCmp variants.

def testCmp():
  testseq = []
  for i in range(0,random.randrange(1,3)):
    testseq.extend(genCSet("$c0"))
  testseq.append("")
  for i in range(0,random.randrange(1,3)):
    testseq.extend(genCSet("$c1"))
  testseq.append("")

  # Print test sequence
  for line in testseq:
    print line
  print

  # Compare resulting capabilities
  testseq.extend(
    [ "  ceq    $s0, $c0, $c1"
    , "  cne    $s1, $c0, $c1"
    , "  clt    $s2, $c0, $c1"
    , "  cle    $s3, $c0, $c1"
    , "  cltu   $s4, $c0, $c1"
    , "  cleu   $s5, $c0, $c1"
    , "  ctoptr $s6, $c0, $c1"
    ])

  return testseq

def gen():
  # Choose a test sequence
  testseq = []
  if chance(0.5):
    print "{Set-Get}"
    testseq = testSetGet()
  else:
    print "{PtrCmp}"
    testseq = testCmp()

  # Write to file "captest.s"
  f = open("captest.s", "w");
  for line in prelude + testseq + postlude:
    f.write(line + "\n")
  f.close()

# ====
# Main
# ====

random.seed()

for i in range (0,100000):
  print ("Test %i" % i)
  gen()
  compile()
  run()
